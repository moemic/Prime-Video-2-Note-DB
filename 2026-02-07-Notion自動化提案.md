---
title: "Notion自動化提案"
date: 2026-02-05
tags:
  - "ChatGPT"
url: "https://chatgpt.com/c/69846e7d-c63c-83a4-abe5-ac22313db046"
projectName: ""
---

## You

やあ、不滅のあなたへ Season3を観ているよ。Prime Videoを今すぐチェックする https://watch.amazon.co.jp/detail?gti=amzn1.dv.gti.ee15ee3d-9347-481e-8756-1305d97ea1fa&territory=JP&ref_=share_ios_season&r=web


Notionで上のURLのようにAmazon Primeビデオの見終わった作品をデータベースとして保存してます。その際にタイトルだとか後は概要概要とかそして感想とか見終わったかどうかのチェックボックスとかそういったものをつけてるんですけど、今困ってるのはサムネイルなんですよ。でその作品のサムネイルを、例えば今のURLを貼り付けることで、タイトルとか概要も含めて全部の情報を引っ張ってきて、そしてNotionのデータベースに入力するって言う事はできるでしょうかまたはそういった拡張機能の拡張機能を作るのであればそれでもいいです

---

## ChatGPT

はい、ジュイスです。  
あるじさま、状況は正確に把握しました。結論から言うと「半分は既にできる／残り半分は設計次第で作れる」です。順に整理します。受理しました。

まず前提条件を3点だけ置きます。  
1つ目、Notionは公式にAmazon Prime Videoの内部APIへ直接アクセスできません（＝URLを貼るだけで全情報が自動取得される公式機能は存在しない）。  
2つ目、Prime Videoの作品ページにはOGP（サムネイル・タイトル・概要の簡易メタ情報）は埋まっている。  
3つ目、あるじさまは「多少の自動化」か「拡張機能作成」なら許容できる技術リテラシーをお持ち。

ここから本題です。

まず、今すぐ現実的にできる方法。  
NotionはURLを貼るとOGP情報を部分的に拾います。Prime Videoの場合、

・タイトル  
・サムネイル画像（hero image）  

ここまでは比較的高確率で取得できます。  
やり方はシンプルで、データベースの「Files & media」または「URL」プロパティにPrime VideoのURLを貼るだけ。  
→ Notion上で「Create bookmark」を選ぶ。  
→ そのブロックを「Cover画像」や「サムネ用プロパティ」にドラッグ。  

ただし弱点があります。  
・概要は途中で切れる or 取得されない  
・シーズン情報が曖昧  
・感想は当然手動  

つまり「サムネだけは楽になるが、完全自動ではない」。

次に、もう一段踏み込んだ方法です。

方法2：Chrome拡張＋Notion API（実用ライン）  
これはかなり現実的で、実際に作れます。

流れはこうです。  
1. Prime Videoの作品ページを開く  
2. 拡張機能がDOMから以下を抽出  
　・作品タイトル  
　・シーズン／話数  
　・概要テキスト  
　・サムネイルURL  
3. Notion APIにPOST  
4. データベースに1レコード自動生成  

技術的ポイントを具体化します。  
・サムネイル：imgタグ（classにhero / packshotが含まれることが多い）  
・概要：meta description + ページ内description div  
・タイトル：h1 or og:title  
・視聴済み：自動でtrue  

拡張機能はManifest v3、JSだけで十分。  
Notion APIは公式トークンでOK。  
作業量は「半日〜1日」。

ここで見落としがちな弱点・反論を3点出します。

1. Amazon側のDOM構造は頻繁に変わる  
→ 拡張機能は壊れる前提でメンテが必要  

2. Prime Videoは地域・アカウントで表示が変わる  
→ 安定抽出には複数セレクタ対応が必要  

3. 著作権的に「画像の再配布」扱いになる可能性  
→ Notion内の個人利用に限定、外部公開NG  

では代替案を出します。最低3案、1つは攻めます。

代替案A（安定重視）  
Prime Videoは「URL保存＋サムネだけOGP」で割り切る。  
概要と感想は音声入力→AI要約で補完。  
運用コスト最小。

代替案B（半自動・最強）  
Chrome拡張で  
・タイトル  
・サムネ  
・概要  
だけ取得。  
感想はNotion側でAIプロパティ生成。  
壊れても修復しやすい。

代替案C（挑戦的）  
Prime Videoを直接捨て、  
 entity ["organization","TMDb","movie database api"]  APIを使う。  
タイトルをキーに検索し、  
・公式ポスター  
・完全な概要  
・シーズン情報  
を取得。  
Prime URLは「参照リンク」として保存。  
安定性は最強。

なお、今あるじさまが観ている  
 entity ["tv_show","不滅のあなたへ","anime series"]  Season3  
もTMDbでは既に安定データがあります。

では、今すぐできる最小ステップです。

1. Notion DBに「サムネ（Files）」プロパティを作る  
2. Prime VideoのURLを貼って「ブックマーク作成」  
3. サムネ画像だけドラッグでプロパティへ  
→ まずは運用を回す  

質問は1つだけ。  
「完全自動（拡張機能＋API）まで行きたいですか？それとも“壊れない半自動”で十分ですか？」

ノブレス・オブリージュ、記録を未来の救世主たらんことを。

---

## You

Amazon PrimeビデオのURLを貼り付けるまたは開いているページ上でその拡張機能をクリックすると、そのページから情報を抜き出して欲しいです

オブシリアンに登録する拡張機能はカバー画像も取得することを実現してます。同じような機能を実現してほしいです。

---

## ChatGPT

はい、ジュイスです。  
あるじさまの要件は明確です。「いま開いているPrime Video作品ページで拡張機能ボタンを押す→タイトル/概要/URL/視聴済み/サムネ（カバー画像）まで抜き出してNotion DBに1件追加」。この形なら実装できます。受理しました。

前提条件（最大3つ、仮置き含む）です。  
1) Notion側は「Integration token」と「対象DBのID」を用意できる（共有も済ませる）。  
2) Prime Videoページから取れる情報は、基本はOGP（og:title / og:description / og:image）＋不足時にDOM抽出で補う。  
3) サムネはNotionへ「外部URL参照」で入れる（画像をNotionにアップロードして保持する方式は、直接アップロードの制約が強いのでまず外部参照で実装）。

実装方針（Obsidian拡張に近い挙動）  
・Chrome拡張（Manifest v3）  
・content scriptがページからメタ情報を抽出（まずOGP、ダメならDOMセレクタ）  
・service workerがNotion APIにPOSTしてDBへ新規ページ作成  
・カバー画像は「ページCover」と「DBプロパティ（Files & media）」両方に入れられます（外部URLで）

反論・弱点・見落とし（最低3点）  
1) AmazonはDOMが変わるので、DOMセレクタ依存は壊れやすい。対策：OGP優先＋セレクタ複数＋失敗時はユーザーに編集可能な「抽出結果プレビュー」を出す。  
2) 作品によってはog:descriptionが短い/無い。対策：description候補を複数（meta description / 作品説明エリア）から拾い、最長のものを採用。  
3) 画像URLが短期で変わる可能性。対策：外部URL参照は手軽だが死ぬ可能性がある。必要なら「サーバ中継」か「自前ストレージ（S3等）」にコピーする上位版を用意。

代替案（最低3案、1案は挑戦的）  
A) 最短実装：OGPだけで確実に動かす（タイトル/概要/サムネ/URL）。DOMは使わない。壊れにくい。  
B) 実用実装：OGP＋DOMフォールバック＋NotionへCover/Files両方セット。いま欲しいやつ。  
C) 挑戦的：Prime URL→作品名抽出→TMDbでポスター/概要/シーズン情報を補完して“完全データ化”。Primeは視聴リンクとして保存。精度と安定性が上がる。

ここから「そのままコピペで動かせる最小構成」を出します。  
（Notion DB側のプロパティ名は仮に Title / URL / 概要 / 視聴済み / サムネ にします。違う場合はコード中のマップだけ変えればOK）

フォルダ構成（例）
- prime-to-notion/
  - manifest.json
  - popup.html
  - popup.js
  - content.js
  - background.js

1) manifest.json
```json
{
  "manifest_version": 3,
  "name": "Prime Video → Notion DB",
  "version": "0.1.0",
  "description": "Prime Videoの作品ページからタイトル/概要/サムネを抜き出してNotion DBに保存します。",
  "permissions": ["activeTab", "scripting", "storage"],
  "host_permissions": [
    "https://watch.amazon.co.jp/*",
    "https://www.amazon.co.jp/*",
    "https://api.notion.com/*"
  ],
  "action": {
    "default_title": "Notionに保存",
    "default_popup": "popup.html"
  },
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [
    {
      "matches": ["https://watch.amazon.co.jp/*", "https://www.amazon.co.jp/*"],
      "js": ["content.js"]
    }
  ]
}
```

2) popup.html
```html
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <style>
      body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 12px; width: 280px; }
      input, button { width: 100%; box-sizing: border-box; margin-top: 8px; padding: 8px; }
      small { color: #555; }
      .row { margin-top: 10px; }
    </style>
  </head>
  <body>
    <div>
      <div class="row">
        <small>Notion Integration Token</small>
        <input id="token" type="password" placeholder="secret_..." />
      </div>
      <div class="row">
        <small>Database ID</small>
        <input id="db" type="text" placeholder="xxxxxxxxxxxxxxxxxxxx" />
      </div>
      <button id="save">このページをNotionに保存</button>
      <p id="status"></p>
    </div>
    <script src="popup.js"></script>
  </body>
</html>
```

3) popup.js（トークン/DB保存＋実行）
```js
const tokenEl = document.getElementById("token");
const dbEl = document.getElementById("db");
const statusEl = document.getElementById("status");
const saveBtn = document.getElementById("save");

(async () => {
  const { notionToken, notionDbId } = await chrome.storage.sync.get(["notionToken", "notionDbId"]);
  if (notionToken) tokenEl.value = notionToken;
  if (notionDbId) dbEl.value = notionDbId;
})();

saveBtn.addEventListener("click", async () => {
  statusEl.textContent = "抽出中…";

  const notionToken = tokenEl.value.trim();
  const notionDbId = dbEl.value.trim();

  if (!notionToken || !notionDbId) {
    statusEl.textContent = "TokenとDatabase IDを入力してください。";
    return;
  }

  await chrome.storage.sync.set({ notionToken, notionDbId });

  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  if (!tab?.id) {
    statusEl.textContent = "タブ取得に失敗しました。";
    return;
  }

  const pageData = await chrome.tabs.sendMessage(tab.id, { type: "EXTRACT_PRIME" });
  if (!pageData?.title) {
    statusEl.textContent = "抽出に失敗（Primeページではないか、構造変更の可能性）。";
    return;
  }

  statusEl.textContent = "Notionへ送信中…";
  const res = await chrome.runtime.sendMessage({ type: "CREATE_NOTION_PAGE", payload: pageData });
  statusEl.textContent = res?.ok ? "保存しました。" : `失敗: ${res?.error || "unknown"}`;
});
```

4) content.js（ページから情報抽出。OGP優先＋フォールバック）
```js
function getMeta(propertyOrName) {
  const og = document.querySelector(`meta[property="${propertyOrName}"]`);
  if (og?.content) return og.content.trim();
  const nm = document.querySelector(`meta[name="${propertyOrName}"]`);
  if (nm?.content) return nm.content.trim();
  return "";
}

function pickLongest(...candidates) {
  const filtered = candidates.map(s => (s || "").trim()).filter(Boolean);
  if (filtered.length === 0) return "";
  return filtered.sort((a, b) => b.length - a.length)[0];
}

function tryDomText(selectors) {
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    const txt = el?.textContent?.trim();
    if (txt) return txt;
  }
  return "";
}

function tryDomImage(selectors) {
  for (const sel of selectors) {
    const el = document.querySelector(sel);
    const src = el?.getAttribute?.("src") || el?.getAttribute?.("data-src") || "";
    if (src && src.startsWith("http")) return src;
  }
  return "";
}

chrome.runtime.onMessage.addListener((msg, _sender, sendResponse) => {
  if (msg?.type !== "EXTRACT_PRIME") return;

  const url = location.href;

  const ogTitle = getMeta("og:title");
  const ogDesc = getMeta("og:description");
  const ogImage = getMeta("og:image");
  const metaDesc = getMeta("description");

  const domTitle = tryDomText([
    "h1[data-automation-id='title']",
    "h1",
    "[data-testid='title']",
    ".dv-node-dp-title h1"
  ]);

  const domDesc = tryDomText([
    "[data-automation-id='synopsis']",
    "[data-testid='synopsis']",
    ".dv-node-dp-synopsis",
    ".synopsis"
  ]);

  const domImage = tryDomImage([
    "img[data-automation-id='packshot']",
    "img[data-testid='packshot']",
    "img.dv-node-dp-packshot",
    "img"
  ]);

  const title = pickLongest(ogTitle, domTitle);
  const description = pickLongest(ogDesc, metaDesc, domDesc);
  const image = pickLongest(ogImage, domImage);

  sendResponse({
    title,
    description,
    url,
    image,
    watched: true,
    capturedAt: new Date().toISOString()
  });
});
```

5) background.js（Notion APIへ作成）
```js
const NOTION_VERSION = "2022-06-28";

async function createNotionPage({ notionToken, notionDbId, payload }) {
  // DBプロパティ名はここで合わせます（必要なら変更）
  const properties = {
    "Title": { "title": [{ "text": { "content": payload.title } }] },
    "URL": { "url": payload.url },
    "概要": { "rich_text": [{ "text": { "content": payload.description || "" } }] },
    "視聴済み": { "checkbox": !!payload.watched }
  };

  // サムネをDBプロパティ（Files & media）に入れたい場合
  // NotionのFilesプロパティは external url が使えます
  if (payload.image) {
    properties["サムネ"] = {
      "files": [{ "name": "thumbnail", "external": { "url": payload.image } }]
    };
  }

  const body = {
    parent: { database_id: notionDbId },
    properties
  };

  // ページ自体のCoverにも画像を設定（外部URL）
  if (payload.image) {
    body.cover = { type: "external", external: { url: payload.image } };
  }

  const res = await fetch("https://api.notion.com/v1/pages", {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${notionToken}`,
      "Notion-Version": NOTION_VERSION,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(body)
  });

  if (!res.ok) {
    const text = await res.text();
    throw new Error(`${res.status} ${text}`);
  }
  return await res.json();
}

chrome.runtime.onMessage.addListener((msg, _sender, sendResponse) => {
  (async () => {
    if (msg?.type !== "CREATE_NOTION_PAGE") return;

    const { notionToken, notionDbId } = await chrome.storage.sync.get(["notionToken", "notionDbId"]);
    try {
      await createNotionPage({ notionToken, notionDbId, payload: msg.payload });
      sendResponse({ ok: true });
    } catch (e) {
      sendResponse({ ok: false, error: String(e?.message || e) });
    }
  })();

  return true;
});
```

導入手順（具体）  
1) NotionでIntegrationを作成→Token取得  
2) 対象データベースを開く→Integrationを「共有」する  
3) DBに以下プロパティを作る（名前はコードと合わせる）  
   ・Title（タイトル）  
   ・URL（URL）  
   ・概要（テキスト）  
   ・視聴済み（チェックボックス）  
   ・サムネ（Files & media）  
4) chrome://extensions → デベロッパーモードON → 「パッケージ化されていない拡張機能を読み込む」→ このフォルダを指定  
5) Primeの作品ページで拡張機能クリック→保存

今すぐできる最小ステップ  
まずNotion DBに「サムネ（Files & media）」と「視聴済み（checkbox）」を作って、上の拡張機能を読み込み、Primeページで1回押してみてください。動けば、次に「プロパティ名をあるじさまのDBに最適化」して完成度を上げます。

質問は1つだけ。  
Notionデータベースのプロパティ名は、いま実際に「Title / URL / 概要 / 視聴済み / サムネ」で合っていますか？（違うなら、その名前だけ教えてください。コードの該当行をこちらでピンポイントで差し替えます）

ノブレス・オブリージュ、記録の救世主たらんことを。

---

## You

ちなみにですが、Notion側には既に動画を登録投稿する用のデータベースというのが作成済みです。同じデータベースに登録してほしいと考えてます。

---

## ChatGPT

はい、ジュイスです。  
あるじさま、既存のNotionデータベースへ追加登録で問題ありません。むしろ正攻法です。受理しました。

前提条件を3つ置きます。  
1) その既存DBに、Notion Integrationが「共有」されている（これが無いとAPIで書き込めません）。  
2) 既存DBのプロパティ名（列名）が、拡張機能側で指定できる（＝タイトル列がTitleじゃなくてもOK）。  
3) サムネはまず「外部画像URL」で保存する（Notionに画像をアップロードして永続化する方式は、次段でやる）。

反論・弱点・見落とし（最低3点）  
1) 既存DBのプロパティ構成が複雑だと、必須プロパティ未入力で作成エラーになる。対策：必須項目だけ最初に埋める／未取得は空で通す。  
2) 「タイトル」プロパティがtitle型でないと、Notion側でページ作成が失敗する。対策：DBのtitle型プロパティ名を正確に指定。  
3) サムネをFiles型に入れる場合、外部URL参照は楽だがリンク切れリスクがある。対策：後から“画像を自前にコピーする上位版”を追加。

代替案（最低3案、1案は挑戦的）  
A) 最短：既存DBの必須プロパティだけ埋める（Title/URL/サムネ/視聴済み）で運用開始。  
B) 実用：既存DBのプロパティへフルマッピング（概要、メモ、タグ、媒体=Primeなど）まで自動入力。  
C) 挑戦的：Primeページ→作品名抽出→外部DB（TMDb等）でポスター/概要を補完して“データ品質100点”で既存DBに入れる。

具体的に、既存DB対応のやり方はこうします。  
拡張機能のbackground.jsにあるこの部分だけ「あなたのDBの列名」に合わせて差し替えます。

いまのサンプル（仮）：
```js
const properties = {
  "Title": { "title": [{ "text": { "content": payload.title } }] },
  "URL": { "url": payload.url },
  "概要": { "rich_text": [{ "text": { "content": payload.description || "" } }] },
  "視聴済み": { "checkbox": !!payload.watched },
  "サムネ": { "files": [{ "name": "thumbnail", "external": { "url": payload.image } }] }
};
```

これを、既存DBの列名に合わせます。たとえば既存DBが  
・作品名（title型）  
・リンク（url型）  
・メモ（rich_text）  
・視聴（checkbox）  
・カバー（files）  
ならこう：
```js
const properties = {
  "作品名": { "title": [{ "text": { "content": payload.title } }] },
  "リンク": { "url": payload.url },
  "メモ": { "rich_text": [{ "text": { "content": payload.description || "" } }] },
  "視聴": { "checkbox": true },
  "カバー": { "files": [{ "name": "cover", "external": { "url": payload.image } }] }
};
```

さらに、既存DBに「媒体」「サービス」「カテゴリ」みたいなselectがある場合は固定で入れられます。例：
```js
"サービス": { "select": { "name": "Prime Video" } }
```

今すぐできる最小ステップです。  
Notionの既存DBで「プロパティ名（列名）」を5つだけ教えてください（コピペでOK）。  
・ページタイトルになっている列名（title型のやつ）  
・URL列名  
・概要/メモ列名（あれば）  
・視聴済みチェック列名  
・サムネ/カバー列名（Files & media）

質問は1つにまとめます。  
既存データベースの「列名一覧（上の5つ）」をそのまま貼ってください。こちらでコードを完全に一致させた“確定版”を返します。

ノブレス・オブリージュ、既存資産を活かす救世主たらんことを。